use num::bigint::BigUint;
use num::ToPrimitive;
use std::io;

fn str_to_biguint(str: &str) -> BigUint {
    BigUint::parse_bytes(str.as_bytes(), 10).unwrap()
}

fn biguint_in_range(num: &BigUint, start: &str, end: &str) -> bool {
    &str_to_biguint(start) <= num && num <= &str_to_biguint(end)
}


fn get_illion(num: String) -> String {
    let big_num: BigUint = str_to_biguint(&num);
    let mut illion: String = String::new();

    let base_prefixes: [&str; 10] = ["", "m", "b", "tr", "quadr", "quint", "sext", "sept", "oct", "non"];
    let unit_prefixes: [&str; 10] = ["", "un", "du", "tre", "quattuor", "quin", "se", "septe", "octo", "nove"];
    let ten_prefixes: [&str; 10] = ["", "dec", "vigint", "trigint", "quadragint", "quinquagint", "sexagint", "septuagint", "octogint", "nonagint"];
    let hundred_prefixes: [&str; 10] = ["", "cent", "ducent", "trecent", "quadringent", "quingent", "sescent", "septingent", "octingent", "nongent"];
    let tier_two_prefixes: [&str; 10] = ["", "milli", "micr", "nan", "pic", "femt", "att", "zept", "yoct", "xon"];

    if biguint_in_range(&big_num, "1", "9") {
        illion.push_str(base_prefixes[big_num.to_u32().unwrap() as usize]);
        illion.push_str("illion");
    } else if biguint_in_range(&big_num, "10", "99") {
        let ten: u32 = big_num.to_u32().unwrap() / 10;
        let unit: u32 = big_num.to_u32().unwrap() % 10;

        let ten_prefix: &str = ten_prefixes[ten as usize];
        let mut unit_prefix: String = String::from(unit_prefixes[unit as usize]);
        match unit {

            3 => {
                unit_prefix.push_str(if ten == 2 || ten == 3 { "s" } else { "" });
            },
            6 => {
                unit_prefix.push_str(if ten == 2 || ten == 3 { "s" } else { "x" });
            },
            7 => {
                unit_prefix.push_str(if ten == 2 { "m" } else { "n" });
            },
            9 => {
                unit_prefix.push_str(if ten == 3 { "n" } else { "m" });
            }
            _ => (),
        }

        illion.push_str(&unit_prefix);
        illion.push_str(ten_prefix);
        illion.push_str("illion");
    } else if biguint_in_range(&big_num, "100", "999") {
        let hundred: u32 = big_num.to_u32().unwrap() / 100;
        let ten: u32 = big_num.to_u32().unwrap() / 10 % 10;
        let unit: u32 = big_num.to_u32().unwrap() % 10;

        let hundred_prefix: &str = hundred_prefixes[hundred as usize];

        let mut ten_prefix: String = String::from(ten_prefixes[ten as usize]);
        if ten != 0 {
            ten_prefix.push_str(if ten == 1 || ten == 2 { "i" } else { "a" });
        } 

        let mut unit_prefix: String = String::from(unit_prefixes[unit as usize]);
        unit_prefix.push_str(if unit == 6 { "x" } else { "" });
        unit_prefix.push_str(if unit == 7 { "n" } else { "" });
        unit_prefix.push_str(if unit == 9 { "m" } else { "" });

        illion.push_str(&unit_prefix);
        illion.push_str(&ten_prefix);
        illion.push_str(&hundred_prefix);
        illion.push_str("illion");
    } else if biguint_in_range(&big_num, "1000", "1000000000000000000000000000") {
        println!(&big_num.to_str_radix(10));
    }

    illion
}

fn main() {
    loop {
        println!("-illion number (type 0 to exit):");
        let mut input = String::new();
        io::stdin().read_line(&mut input).expect("Failed to read input");
        input = input.trim().to_string();

        if input == "0" { break; }
        if input.chars().all(|c| c.is_ascii_digit()) { println!("{}\n", get_illion(input)); }
    }
}
